import { eq, and, or, ilike, SQL, desc } from 'drizzle-orm';
import { db } from '../db';
import { customers } from '../db/schema';
import { AppError } from '../middleware/error.middleware';
import { z } from 'zod';

export const customerSchema = z.object({
    fullName: z.string().min(2, 'Nome obrigatório'),
    documentType: z.enum(['CPF', 'CNPJ']).default('CPF'),
    documentNumber: z.string().min(11, 'Documento inválido'),
    phoneNumber: z.string().min(10, 'Telefone inválido'),
    email: z.string().email().optional().or(z.literal('')),
    addressStreet: z.string().optional(),
    addressNumber: z.string().optional(),
    addressComplement: z.string().optional(),
    addressNeighborhood: z.string().optional(),
    addressCity: z.string().optional(),
    addressState: z.string().optional(),
    addressZipCode: z.string().optional(),
    isBlocked: z.boolean().default(false),
    notes: z.string().optional(),
});

export async function listCustomers(tenantId: string, filters: { isBlocked?: boolean; search?: string }) {
    const rows = await db
        .select()
        .from(customers)
        .where(eq(customers.tenantId, tenantId))
        .orderBy(customers.fullName);

    let result = rows;
    if (filters.isBlocked !== undefined) {
        result = result.filter((c) => c.isBlocked === filters.isBlocked);
    }
    if (filters.search) {
        const s = filters.search.toLowerCase();
        result = result.filter(
            (c) =>
                c.fullName.toLowerCase().includes(s) ||
                c.documentNumber.includes(s) ||
                c.phoneNumber.includes(s)
        );
    }
    return result;
}

export async function getCustomer(tenantId: string, id: string) {
    const [customer] = await db.select().from(customers).where(and(eq(customers.tenantId, tenantId), eq(customers.id, id)));
    if (!customer) throw new AppError(404, 'Cliente não encontrado');
    return customer;
}

export async function createCustomer(tenantId: string, data: z.infer<typeof customerSchema>) {
    const [customer] = await db.insert(customers).values({ tenantId, ...data, email: data.email || null }).returning();
    return customer;
}

export async function updateCustomer(tenantId: string, id: string, data: Partial<z.infer<typeof customerSchema>>) {
    const [customer] = await db
        .update(customers)
        .set({ ...data, email: data.email || null, updatedAt: new Date() })
        .where(and(eq(customers.tenantId, tenantId), eq(customers.id, id)))
        .returning();
    if (!customer) throw new AppError(404, 'Cliente não encontrado');
    return customer;
}

export async function deleteCustomer(tenantId: string, id: string) {
    const [customer] = await db.delete(customers).where(and(eq(customers.tenantId, tenantId), eq(customers.id, id))).returning();
    if (!customer) throw new AppError(404, 'Cliente não encontrado');
    return { success: true };
}
